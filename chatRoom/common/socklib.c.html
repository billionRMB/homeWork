<p>/<strong><em>*</em><em>*</em><em>*</em><em>*</em><em>*</em><em>*</em><em>*</em><em>*</em><em>*</em><em>*</em><em>*</em><em>*</em><em>*</em><em>*</em><em>*</em><em>*</em><em>*</em><em>*</em><em>*</em><em>*</em><em>*</em><em>*</em><em>*</em></strong></p>

<blockquote>
  <p>File Name: socklib.c
Author:Gin.TaMa 
Mail:1137554811@qq.com 
Created Time: 2019年02月23日 星期六 11时02分06秒
 <strong><em>*</em><em>*</em><em>*</em><em>*</em><em>*</em><em>*</em><em>*</em><em>*</em><em>*</em><em>*</em><em>*</em><em>*</em><em>*</em><em>*</em><em>*</em><em>*</em><em>*</em><em>*</em><em>*</em><em>*</em><em>*</em><em>*</em>**</strong>/</p>

<h1>include "socklib.h"</h1>
</blockquote>

<p>int strToInt(char<em>str){
    int ans = 0;
    for(int i = 0;str[i];i++){
        ans = ans</em>10 + str[i] - '0';
    }
    return ans;
}
int connect<em>to</em>server(char* IP,int port){</p>

<pre><code>int sockfd;
if((sockfd=socket(AF_INET,SOCK_STREAM,0))==-1){
    perror("make socket:");
    return -1;
}

struct sockaddr_in their_add;
their_add.sin_family = AF_INET;
their_add.sin_port = htons(port);
their_add.sin_addr.s_addr=inet_addr(IP);
bzero(&amp;(their_add.sin_zero),8);

if(connect(sockfd,(struct sockaddr*)&amp;their_add,sizeof(struct sockaddr)) == -1){
   perror("connect server failed:");  
   close(sockfd);
   return -1;
}
return sockfd;
</code></pre>

<p>}</p>

<p>int make<em>server</em>socket(int port,int q<em>size){
    int socket</em>id;
    // 初始化 socket
    if((socket<em>id = socket(AF</em>INET,SOCK<em>STREAM,0)) == -1){
        printf("create socket error: %s\n",strerror(errno));
        exit(1);
    }
    // 初始化地址端口
    struct sockaddr</em>in saddr;
    memset(&amp;saddr,0,sizeof(saddr));
    saddr.sin<em>family = AF</em>INET;
    saddr.sin<em>port = htons(port);
    saddr.sin</em>addr.s<em>addr = htonl(INADDR</em>ANY);</p>

<pre><code>if(bind(socket_id,(struct sockaddr*)&amp;saddr,sizeof(saddr)) == -1){
    printf("bind socket error:%s\n",strerror(errno));
    close(socket_id);
    exit(1);
}

if( listen(socket_id,q_size) == -1 ){
    printf("listen socket error:%s\n",strerror(errno));
    close(socket_id);
    exit(1);
}
return socket_id;
</code></pre>

<p>}
// 获得从这个buff开始到结束的字符的字符串
char* get_a(char* buff,char endChar){
    int i = 0;
    while(buff[i]!=endChar)i++;
    char* result = calloc(i,sizeof(char));
    strncpy(result,buff,i);
    return result;
}</p>

<p>int get<em>conf</em>value(char <em>pathname, char *key_name,char</em> value){
    int fd;
    if((fd = open(pathname,O<em>RDONLY)) == -1){
        printf("Wrong open %s\n",pathname);
        return -1;
    }
    // 获取文件长度
    int length = lseek(fd,0,SEEK</em>END);
    lseek(fd,0,SEEK_SET);</p>

<pre><code>char* buff = calloc(length,sizeof(char));

if(read(fd,buff,length) == -1){
    printf("Failed to read\n");
    return -1;
}

int len = strlen(key_name),i = 0;

while(i &lt; length){
    char* temp = get_a(buff+i,'=');
    if(strncmp(key_name,temp,len) == 0){
        if(value == NULL){
            value = calloc(strlen(get_a(buff+i+len+1,'\n')),sizeof(char));
        }
        strcpy(value,get_a(buff+i+len+1,'\n'));
        break;
    }else{
        i=i+strlen(temp)+2+strlen(get_a(buff+i+len+1,'\n'));
    }
}

close(fd);

return 0;
</code></pre>

<p>}</p>

<p>void initSCFL(SCFL<em>*sl){
    *sl = calloc(1,sizeof(SCFL));
    (</em>sl) -> cInfo = calloc(1,sizeof(clientInfo));
}</p>

<p>void setTips(SCFL<em>sl,char</em>tips){
    sl->tips = calloc(strlen(tips),sizeof(char));
    strcpy(sl->tips,tips);
}</p>

<p>int runServer(SCFL* serverCF,int mport){
    char filePath[]="./chatroom.conf";
    // 从文件中读取配置
    char* tempport;
    get<em>conf</em>value(filePath,"serverport",tempport);
    // 获得连接
    if(mport==-1){
        port = mport;
    }
    int socket<em>fd = make</em>server<em>socket(port,10);
    int connect</em>fd;
    // 输出server 的提示
    printf("%s",serverCF->tips);
    // 客户端的一部分信息
    while(1){
        if( (connect<em>fd = accept(socket</em>fd, (struct sockaddr<em>)&amp;serverCF->cInfo->saddr_client,(socklen_t</em>)&amp;serverCF->cInfo->clength)) == -1){
        printf("accept socket error: %s(errno: %d)",strerror(errno),errno);
        exit(0);
        }
        int pid = fork();
        if(pid &lt; 0){
            printf("Wrong fork\n");
        }else if(pid == 0){
            // 子进程
            serverCF->process<em>request(connect</em>fd,serverCF->cInfo);
        }
    }
    close(socket_fd);
}</p>
